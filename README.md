<h1 align="center">
  C# Vulkan Libraries
  <br>  
<p align="center">
  <a href="https://www.paypal.me/GrandTetraSoftware">
    <img src="https://img.shields.io/badge/Donate-PayPal-green.svg">
  </a>
</p>
</h1>

# vk.net
<a href="https://www.nuget.org/packages/Vulkan"><img src="https://buildstats.info/nuget/Vulkan"></a>

Autogenerated low level Vulkan c# binding. This project starts as a fork of the work of https://github.com/mellinoe. I made a new generator limiting the number of overrides and trying to avoid use of unsafe raw pointers.
The nuget package is available under the name **Vulkan**.
<p align="center">
  <a href="https://github.com/jpbruyere/vk.net/blob/master/samples/pbr/screenshot.png">
    <kbd><img src="https://raw.githubusercontent.com/jpbruyere/vk.net/master/samples/pbr/screenshot.png" height="300"></kbd>
  </a>
   <br>Port of the gltfPBR from Sacha Willems</br>
</p>

# CVKL
<a href="https://www.nuget.org/packages/CVKL"><img src="https://buildstats.info/nuget/CVKL"></a>

The second project included in this repository is a set of classes encapsulating vulkan objects with `IDispose` model and **reference counting**. [GLFW](https://www.glfw.org/)  handles the windowing system.

Developping exclusively on linux, I would be glad to have some feedback from window experiences.

### Requirements
- [GLFW](https://www.glfw.org/)
- [libstb](https://github.com/nothings/stb), on debian install **libstb-dev**.
- [Vulkan Sdk](https://www.lunarg.com/vulkan-sdk/), **glslc** has to be in the path.
- optionaly for ui, you will need [vkvg](https://github.com/jpbruyere/vkvg).

### Features

- physicaly based rendering, direct and deferred
- glTF 2.0
- ktx image loading.

### VkWindow class

To create a new vulkan application, derrive your application from `VkWindow`.

```csharp
class Program : VkWindow {
	static void Main (string[] args) {
		Instance.VALIDATION = true;
		
		using (Program vke = new Program ()) {
			vke.Run ();
		}
	}
}
```
### Enabling features

Override the `configureEnabledFeatures` method of `VkWindow` to enable features.
```csharp
protected override void configureEnabledFeatures (VkPhysicalDeviceFeatures available_features, ref VkPhysicalDeviceFeatures enabled_features) {
	enabled_features.samplerAnisotropy = available_features.samplerAnisotropy;
}
```
### Creating queues

To create queues, override the `createQueues` method of `VkWindow`. This function is called before the logical device creation and will take care of physically available queues, creating duplicates if count exceed availability. The `base` method will create a default presentable queue.

```csharp
protected override void createQueues () {
	base.createQueues ();
	transferQ = new Queue (dev, VkQueueFlags.Transfer);
}
```
### Rendering

The constructor of the `VkWIndow` will finish the vulkan initialisation, so that you may create pipelines, buffers, and so on in your constructor.

VkWindow will provide the default swapchain, but it's up to you to create the frame buffers. For the triangle example, create them in the `OnResize` override.
```csharp
Framebuffer[] frameBuffers;

protected override void OnResize () {
	if (frameBuffers != null)
		for (int i = 0; i < swapChain.ImageCount; ++i)
			frameBuffers[i]?.Dispose ();
	frameBuffers = new Framebuffer[swapChain.ImageCount];

	for (int i = 0; i < swapChain.ImageCount; ++i) 
		frameBuffers[i] = new Framebuffer (pipeline.RenderPass, swapChain.Width, swapChain.Height,
			(pipeline.Samples == VkSampleCountFlags.SampleCount1) ? new Image[] {
				swapChain.images[i],
				null
			} : new Image[] {
				null,
				null,
				swapChain.images[i]
			});

	buildCommandBuffers ();
}
```

